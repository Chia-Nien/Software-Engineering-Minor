# Goal of minor
The process of designing and developing complex software architectures is a perilous path. In several instances the developer gets lost in a sea of guidelines, anedocts, personal experiences, and ad-hoc tricks that are, most of the times, obstacles and of no assistance. Moreover, they do not provide an objective way of evaluating the "goodness" of the produced architecture. As Software Engineers are no different than other kinds of engineers, we need to rely on unambiguous, objective ways to evaluate the goodness of our work. As, for instance, in civil engineering the laws of physics are applied to ensure that a bridge does not collapse in an objective way (who dares to cross a bridge if the engineer would tell\: "I built it like this because in my personal experience this is the way to build bridges"), the same applies to software engineering\: a software engineer needs solid principles and foundations to build software architectures. In this minor we teach the student to build a framework in a reliable way within very complex domains through type safety and algebraic reasoning, which find concrete applications in\:

- UX component systems.
- OData connector and other ORM's.
- Compiler components such as parsers and type checkers.
- Concurrent systems, such as `async\- await` in .NET or `Promise` in Javascript.


# Structure
2 courses to see theoretical concepts in action.
1 project of choice among four. The projects descriptions can be found in the [course git page](https://github.com/hogeschool/Software-Engineering-Minor)


## Study points
This minor grants you 30 ECTS.

## Contact moments
One lecture per week, for two hours, plus half a day of project practicum a week

## Examination
Each theoretical part is examined through an written exam. For the first part the exam is split in a theory and a programming part, while for the second there is only a theory exam. The details of the assignment examination are listed in their respective descriptions.
